package corejava;

/*
 * 验证（Verification）

　　验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 

	验证阶段大致会完成4个阶段的检验动作：

    1. 文件格式验证：
		    否以魔术0xCAFEBABE开头
		    主次版本号是否在当前虚拟机的处理范围之内
		    常量池中的常量是否有不被支持的类型
		    ...
		验证字节流是否符合Class文件格式的规范    
		保证输入的字节流能正确的解析并存储于方法区内，格式上符合描述一个java类型信息的要求。
		这阶段的验证是基于二进制字节流的，只有通过这阶段的验证，字节流才被允许进入java虚拟机内存的方法区中存储。
		后三个阶段全部基于方法区的存储结构上进行的，不会再直接读取和操作字节流了。
		
	
    2.元数据验证：
		    这个类是否有父类（除了java.lang.Object之外，所有的类都应当由父类）
			这个类的父类是否继承了不允许被继承的类（被final修饰的类）
			如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法
			类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）
			...
	  对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求
	  

    3.字节码验证：
		    保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，
		    	例如不会出现类似这样的情况：在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中。
		    保证跳转指令不会跳转到方法体以外的字节码指令上。
		    保证方法体中的类型转换是有效地，
		    	例如可以把一个子类对象赋值给父类数据类型，这是安全的，
		    	但是把父类对象复制给子类数据类型，甚至把对象赋值给与他毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。
		    ...
	  是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
	  在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，
	  保证被校验类的方法在运行时不会做出危害虚拟机安全的事件

    4. 符号引用验证：
		    符号引用中通过字符串描述的全限定名是否能找到对应的类。
		    在制定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。
		    符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问。
		    ...
    虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。
    符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。
    对于虚拟机的类加载机制来说，验证阶段是一个非常重要的、但不是一定必要（因为对程序运行期没有影响）的阶段。
    如果所运行的全部代码（包括自己编写的及第三方包中的代码）都已经被反复使用和验证过，
    那么在实施阶段就可以考虑使用-Xverify : none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

 * 
 * */
public class Class_Linking {

}
